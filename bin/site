#!/usr/bin/env python
import os
import subprocess
import glob

from tempfile import NamedTemporaryFile
from slugify import slugify
from fire import Fire

HUGO = '/usr/local/bin/hugo'
TELISAR = os.path.expanduser('~/dnd/telisar')


class Posts:
    """
    Generate the correct path names for specific post archetypes, and define post-editing callbacks.
    """
    content_dir = 'content'

    def __init__(self):
        self.working_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
        self.session_counter_path = os.path.join(self.working_dir, 'session_counter')
        self._session_counter = None
        self._valid_types = []

    def abspath(self, post):
        return os.path.join(self.working_dir, self.content_dir, post)

    def update_session_counter(self):
        with open(self.session_counter_path, 'wb') as f:
            f.write(self.session_counter + 1)

    def _filename(self, title, prefix='', path='posts'):
        fn = slugify(title, separator='_')
        if prefix:
            fn = slugify(f'{prefix} {fn}', separator='_')
        return os.path.join(path, f'{fn}.md')

    @property
    def session_counter(self):
        if not self._session_counter:
            try:
                with open(self.session_counter_path) as f:
                    self._session_counter = int(f.read())
            except (OSError, TypeError):
                self._session_counter = 1
        return self._session_counter

    @property
    def valid_types(self):
        if not self._valid_types:
            for pathname in glob.glob(os.path.join(self.working_dir, 'archetypes/*.md')):
                self._valid_types.append(os.path.basename(pathname)[:-3])
        return self._valid_types

    def get_pathname(self, archetype, *args):
        return self._filename(title=' '.join(args))

    def session(self, *args):
        return self._filename(title=' '.join(args), path='posts', prefix=f'episode_{self.session_counter}')

    def monster(self, *args):
        return self._filename(title=' '.join(args), path='beastiary')

    def get_campaign_date(self):
        return subprocess.run(
            [os.path.join(TELISAR, 'calendar'), 'today', 'short'],
            stdout=subprocess.PIPE
        ).stdout.decode('utf-8').strip()

    def get_episode_title(self, args):
        title = ' '.join([s.capitalize() for s in args])
        return f'Episode {self.session_counter}: {title}'

    def insert_metadata(self, path, **metadata):
        # todo: make this do actual yaml but without trashing the markdown etc.
        with NamedTemporaryFile(delete=False) as temp_fh:
            in_metadata = False
            with open(path) as post_fh:
                for line in post_fh:
                    if line == '---\n':
                        in_metadata = not in_metadata
                    if in_metadata:
                        for (key, value) in metadata.items():
                            line = line.replace(key, value)
                    temp_fh.write(line.encode())
        os.rename(temp_fh.name, path)

    def _session_callback(self, post, result, args, kwargs):
        path = self.abspath(post)
        if os.path.exists(path):
            self.insert_metadata(
                path,
                TITLE=self.get_episode_title(args),
                CAMPAIGN_DATE=self.get_campaign_date(),
            )
            self.update_session_counter()


class CLI:
    def __init__(self):
        self._posts = Posts()

    def _hugo(self, archetype, pathname):
        # subprocess.check_call(['git', 'stash'])
        return subprocess.call([HUGO, 'new', '-k', archetype, pathname])

    def _editor(self, post):
        return subprocess.call([os.environ['EDITOR'], self._posts.abspath(post)])

    def _callback(self, archetype, post, result, args, kwargs):
        try:
            callback = getattr(self._posts, f'_{archetype}_callback')
        except AttributeError as e:
            print(e)
            return
        return callback(post, result, args, kwargs)

    def new(self, archetype=None, *args, **kwargs):
        """
        Launch the hugo editor for a new post of the specified archetype. When called wihtout parameters, list the
        supported archetypes.

        Usage:

        new
        new ARCHTYPE TITLE

        Parmeters:

        ARCHETYPE       Any archetype defined in the hugo archtetypes directory.
        TITLE           The title of the post.

        """
        if not archetype:
            print('\n'.join(self._posts.valid_types))
            return
        if archetype not in self._posts.valid_types:
            return f"Unsupported archetype: {archetype}. Valid types: {self._posts.valid_types}"
        if not args:
            return help(CLI.new)
        try:
            post = getattr(self._posts, archetype)(*args)
        except AttributeError:
            post = self._posts.get_pathname(archetype, *args)

        result = self._hugo(archetype, post)
        self._callback(archetype, post, result, args, kwargs)
        self._editor(post)

    def update(self):
        """
        Publish and then save (commit and push) changes.

        Usage:
            site update
        """
        self.publish()
        self.save()

    def save(self, edit=False):
        """
        Commit changes and push the current branch. Pass --edit the edit the commit message.

        Usage:
            site save
            site save --edit=True
        """
        args = ['git', 'commit', '-a']
        if not edit:
            args += ['-m', 'publish checkpoint']
        subprocess.check_call(args)
        subprocess.check_call(['git', 'push'])

    def publish(self, edit=False):
        """
        Update the live website.

        Usage:
            site publish
        """
        subprocess.check_call([HUGO, '-v'])
        subprocess.check_call(' '.join([
            'rsync', '-av',
            os.path.join(self._posts.working_dir, 'public', '*'),
            'nubbin.evilchi.li:/usr/local/deploy/telisar/project/www/'
        ]), shell=True)
        subprocess.call(['git', 'stash', 'pop'])


if __name__ == '__main__':
    Fire(CLI())
